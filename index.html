<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Â¢®Ê∞¥Â∞ÑÊâã - Vector Ink Style</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #111;
            background-image: 
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%, transparent 75%, #1a1a1a 75%, #1a1a1a),
                linear-gradient(45deg, #1a1a1a 25%, transparent 25%, transparent 75%, #1a1a1a 75%, #1a1a1a);
            background-size: 40px 40px;
            background-position: 0 0, 20px 20px;
            animation: bg-scroll 3s linear infinite;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            /* iOS ÂÖºÂÆπÈ´òÂ∫¶Âçï‰Ωç */
            height: 100dvh; 
            width: 100vw;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            overflow: hidden;
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            box-shadow: inset 0 0 200px rgba(0,0,0,0.8);
            touch-action: none;
        }

        @keyframes bg-scroll {
            0% { background-position: 0 0, 20px 20px; }
            100% { background-position: 40px 40px, 60px 60px; }
        }

        #game-container {
            position: relative;
            background-color: #080808; 
            border: 12px solid #2a2a2a; 
            border-radius: 20px; 
            box-shadow: 
                0 0 0 2px #111, 
                0 0 40px rgba(0,0,0,0.8), 
                0 0 20px rgba(0, 255, 230, 0.05);
            background-image: 
                linear-gradient(90deg, rgba(0, 255, 230, 0.08) 1px, transparent 1px),
                linear-gradient(rgba(0, 255, 230, 0.08) 1px, transparent 1px);
            background-size: 40px 40px;
            overflow: hidden;
            z-index: 10; 
            
            /* „ÄêÂÖ≥ÈîÆ‰øÆÂ§ç„ÄëÊåáÂÆöÈ´òÂ∫¶Èò≤Ê≠¢Â°åÈô∑ */
            height: 90vh; 
            width: auto;
            aspect-ratio: 400/700;
            max-width: 95vw; 
            transform: translateZ(0);
        }

        canvas {
            display: block;
            position: absolute; 
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            cursor: crosshair;
            filter: contrast(1.05) brightness(1.1);
            -webkit-tap-highlight-color: transparent;
        }

        #inkCanvas {
            z-index: 1;
            filter: url(#goo);
            opacity: 0.85; 
        }

        #gameCanvas {
            z-index: 5;
            filter: contrast(1.05) brightness(1.1);
        }

        /* ÁßªÂä®Á´ØÈ´òÊÄßËÉΩÊ®°Âºè */
        body.mobile-mode #inkCanvas {
            filter: none !important; 
            opacity: 0.6 !important;
        }
        body.mobile-mode #gameCanvas {
            filter: none !important;
        }
        body.mobile-mode .crt-overlay {
            display: none !important; 
        }
        body.mobile-mode #game-container {
            box-shadow: none !important; 
            border: 1px solid #444;
        }

        .crt-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; 
            z-index: 100; 
            background: 
                linear-gradient(
                    to bottom,
                    rgba(255,255,255,0),
                    rgba(255,255,255,0) 50%,
                    rgba(0,0,0,0.1) 50%, 
                    rgba(0,0,0,0.1)
                );
            background-size: 100% 4px; 
            box-shadow: inset 0 0 80px rgba(0,0,0,0.5);
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 110; 
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            align-items: flex-start; 
            padding: 15px;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            text-shadow: 0 0 5px rgba(255, 255, 255, 0.5); 
            pointer-events: auto;
            position: relative;
        }
        
        #score-board {
            font-size: 20px; 
            font-weight: 900;
            color: #e0f0ff;
            transform: skew(-10deg);
            font-family: 'Courier New', monospace; 
            text-align: left;
            transition: color 0.1s;
        }
        
        @keyframes score-pop {
            0% { transform: scale(1) skew(-10deg); color: #fff; }
            50% { transform: scale(1.5) skew(-10deg); color: #ffff00; text-shadow: 0 0 20px #ffff00; }
            100% { transform: scale(1) skew(-10deg); color: #e0f0ff; }
        }
        
        .score-pop {
            animation: score-pop 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        .high-score {
            font-size: 12px;
            color: #f1c40f;
            display: block;
            margin-top: 4px;
            opacity: 0.8;
        }

        .controls {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            background: rgba(0, 0, 0, 0.5);
            border: 2px solid rgba(0, 255, 230, 0.5);
            color: rgba(0, 255, 230, 0.9);
            width: 36px;
            height: 36px;
            border-radius: 50%;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 230, 0.2);
            touch-action: manipulation;
        }

        .icon-btn:hover {
            background: rgba(0, 255, 230, 0.2);
            transform: scale(1.1);
            box-shadow: 0 0 15px rgba(0, 255, 230, 0.6);
        }
        
        .icon-btn i { font-style: normal; }

        #timer-bar-container {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 6px;
            background: #222;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, #ff007f, #00ffcc);
            box-shadow: 0 0 10px #ff007f; 
            transition: width 0.1s linear;
        }

        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.85);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 120;
            pointer-events: auto;
            backdrop-filter: blur(1px); 
            -webkit-backdrop-filter: blur(1px);
        }

        .overlay.active { display: flex; }
        #game-over-overlay { z-index: 130; }
        
        .splat-text {
            font-size: 40px;
            font-weight: 900;
            color: #bdc3c7;
            margin-bottom: 30px;
            text-shadow: 4px 4px 0 #2c3e50;
            text-align: center;
            font-family: 'Courier New', monospace;
            max-width: 90%;
            line-height: 1.2;
        }
        
        #start-overlay #credits-start {
            position: absolute;
            bottom: 20px; 
            width: 100%;
            text-align: center;
            font-size: 16px;
            color: #00ffcc;
            font-family: 'Courier New', monospace;
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.5);
            font-weight: bold;
        }

        .loading-text {
            color: #aaa;
            font-size: 14px;
            margin-top: 10px;
            text-align: center;
            line-height: 1.5;
        }
        
        .main-btn {
            background-color: transparent;
            color: #00ffcc;
            border: 2px solid #00ffcc;
            padding: 15px 40px;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.2s;
            text-transform: uppercase;
            box-shadow: 0 0 10px rgba(0, 255, 204, 0.3);
            text-shadow: 0 0 5px rgba(0, 255, 204, 0.8);
            font-family: 'Courier New', monospace;
            touch-action: manipulation;
        }

        .main-btn:hover {
            background-color: rgba(0, 255, 204, 0.1);
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 204, 0.6);
        }

        .paused-text {
            font-size: 60px;
            font-weight: 900;
            color: #f1c40f;
            text-transform: uppercase;
            transform: rotate(-5deg);
            text-shadow: 5px 5px 0px #000;
            font-family: 'Courier New', monospace;
        }
        #credits { display: none; }
        
        #countdown-display {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: 'Courier New', monospace;
            font-weight: 900;
            font-size: 80px;
            color: #fff;
            text-shadow: 0 0 20px #ff007f, 0 0 50px #ff007f;
            z-index: 150; 
            pointer-events: none;
            display: none; 
            animation: pop-in 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }
        
        @keyframes pop-in {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        }
    </style>
</head>
<body>
    
    <!-- SVG Filter for Liquid Effect -->
    <svg style="position: absolute; width: 0; height: 0;" xmlns="http://www.w3.org/2000/svg">
        <defs>
            <filter id="goo">
                <feGaussianBlur in="SourceGraphic" stdDeviation="8" result="blur" />
                <feColorMatrix in="blur" mode="matrix" values="1 0 0 0 0  0 1 0 0 0  0 0 1 0 0  0 0 0 19 -9" result="goo" />
                <feComposite in="SourceGraphic" in2="goo" operator="atop"/>
            </filter>
        </defs>
    </svg>

    <div id="game-container">
        <div class="crt-overlay"></div>
        <canvas id="inkCanvas" width="400" height="700"></canvas>
        <canvas id="gameCanvas" width="400" height="700"></canvas>
        
        <div id="countdown-display">READY</div>
        
        <div id="ui-layer">
            <div class="hud-top">
                <div id="score-board">
                    SCORE: <span id="score">0</span>
                    <span class="high-score">HI: <span id="high-score">0</span></span>
                </div>
                <div class="controls">
                    <button class="icon-btn" onclick="toggleMute()" title="ÈùôÈü≥/ÂèñÊ∂àÈùôÈü≥" id="mute-btn"><i>üîä</i></button>
                    <button class="icon-btn" onclick="togglePause()" title="ÊöÇÂÅú (P)">II</button>
                    <button class="icon-btn" onclick="openRestartOverlay()" title="ÈáçÊñ∞ÂºÄÂßã">‚Üª</button>
                </div>
            </div>
            <div id="timer-bar-container">
                <div id="timer-bar"></div>
            </div>
        </div>

        <div id="start-overlay" class="overlay active">
            <div class="splat-text" style="color: #ff007f; text-shadow: 0 0 10px #ff007f;">INK SHOOTER</div>
            <button id="start-btn" class="main-btn">Start Battle</button>
            <div class="loading-text"></div>
            <div id="credits-start">‰ΩúËÄÖÔºödidi & nagi</div>
        </div>

        <div id="pause-overlay" class="overlay">
            <div class="paused-text">PAUSED</div>
            <button class="main-btn" onclick="togglePause()" style="margin-top: 30px; border-color: #f1c40f; color: #f1c40f;">RESUME</button>
            <button class="main-btn" onclick="showStartScreen()" style="margin-top: 15px; background-color: #e74c3c; border-color: #e74c3c; color: #fff; box-shadow: none;">EXIT TO TITLE</button>
        </div>

        <div id="restart-overlay" class="overlay">
            <div class="splat-text" style="font-size: 32px;">RESTART?</div>
            <div style="display: flex; gap: 20px;">
                <button class="main-btn" onclick="confirmRestartAction()" style="color: #00ffcc; border-color: #00ffcc;">YES</button>
                <button class="main-btn" onclick="closeRestartOverlay()" style="color: #e74c3c; border-color: #e74c3c;">NO</button>
            </div>
        </div>

        <div id="game-over-overlay" class="overlay">
            <h2 class="splat-text" style="color: #ff007f; text-shadow: 0 0 15px #ff007f;">GAME OVER</h2>
            <p style="color: #fff; font-size: 20px; margin-bottom: 10px; font-family: monospace;">SCORE: <span id="final-score">0</span></p>
            <p id="new-record-text" style="color: #f1c40f; font-size: 16px; margin-bottom: 30px; display:none; font-weight:bold;">‚ú® NEW RECORD! ‚ú®</p>
            <button class="main-btn" onclick="resetGame()">RETRY</button>
            <button class="main-btn" onclick="showStartScreen()" style="margin-top: 15px; background-color: #e74c3c; border-color: #e74c3c; color: #fff; box-shadow: none;">EXIT TO TITLE</button>
        </div>
    </div>

    <script>
        // Ê£ÄÊµãÁßªÂä®Á´ØËÆæÂ§á
        const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
        if (isMobile) {
            document.body.classList.add('mobile-mode');
        }
        
        window.onerror = function(msg, url, line) {
            // console.error(`Error: ${msg} at ${line}`);
        };

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const inkCanvas = document.getElementById('inkCanvas');
        const inkCtx = inkCanvas.getContext('2d');

        // Ê†∏ÂøÉ‰ºòÂåñÔºöÈîÅÂÆöÂÜÖÈÉ®Ê∏≤ÊüìÂàÜËæ®Áéá
        canvas.width = 400;
        canvas.height = 700;
        inkCanvas.width = 400;
        inkCanvas.height = 700;

        const scoreEl = document.getElementById('score');
        const highScoreEl = document.getElementById('high-score'); 
        const finalScoreEl = document.getElementById('final-score');
        const newRecordText = document.getElementById('new-record-text');
        const timerBarEl = document.getElementById('timer-bar');
        const muteBtn = document.getElementById('mute-btn');
        const countdownEl = document.getElementById('countdown-display');
        
        const startOverlay = document.getElementById('start-overlay');
        const pauseOverlay = document.getElementById('pause-overlay');
        const restartOverlay = document.getElementById('restart-overlay');
        const gameOverOverlay = document.getElementById('game-over-overlay');
        const startBtn = document.getElementById('start-btn');

        const GRID_ROWS = 16; 
        const GRID_COLS = 8;
        const TILE_RADIUS = 24;
        const TILE_DIAMETER = TILE_RADIUS * 2;
        const ROW_HEIGHT = TILE_RADIUS * Math.sqrt(3);
        const DEAD_LINE_ROW = GRID_ROWS - 2;
        const DEAD_LINE_Y = (DEAD_LINE_ROW * ROW_HEIGHT) + 20;

        const MAX_INK_SPLATS = isMobile ? 10 : 25;
        const PARTICLE_COUNT = isMobile ? 4 : 8;

        const DEFAULT_PLACEHOLDER = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAEAAAABACAYAAACqVqWJAAAAf0lEQVR4Xu3RAQQAIAzDMPj/pHIBA7k7/y5N7kQAAAAAAAAAAACgV42zL8/15Y4X7v3o5J32u/2T2fD1c1e/AAAAAAAAAAAAoF/l/Qn/J5EAAAAAAAAAAACgX+UAAAAAAAAAAAAAwK/yAQAAAAAAAAAAANBfXgAAAAAAAAAAAACgV3IAAAAAAAAAAAAAYG/f8/F1Y4j/n/kAAAAASUVORK5CYII=";
        
        // ================== ÂõæÁâáÈÖçÁΩÆÂå∫Âüü (‰∏∫ÊØè‰∏™ÁêÉÂàÜÈÖçÁã¨Á´ã‰ΩçÁΩÆ) ==================
        const IMG_PINK = DEFAULT_PLACEHOLDER; 
        const IMG_GREEN = DEFAULT_PLACEHOLDER;
        const IMG_BLUE = DEFAULT_PLACEHOLDER;
        const IMG_ORANGE = DEFAULT_PLACEHOLDER;
        const IMG_PURPLE = DEFAULT_PLACEHOLDER;
        
        const BGM_CUSTOM_URL = "data:audio/mp3;base64,PLACEHOLDER_NO_BGM"; 

        // ÂÖ®Â±ÄÁä∂ÊÄÅÂèòÈáè
        let audioCtx = null; 
        let gridOffset = 0; 
        let grid = []; 
        let particles = []; 
        let fallingBubbles = []; 
        let inkSplats = [];
        let floatingTexts = []; 
        let currentBubble = null;
        let nextBubbleType = null;
        let score = 0;
        let highScore = 0; 
        let isGameOver = false;
        let isPaused = true; 
        let animationId;
        let shakeX = 0; 
        let shakeY = 0; 
        let shakeDuration = 0;
        let comboPitchMultiplier = 1.0; 
        let gameState = 'MENU'; 
        let countdownValue = 3;
        let countdownScale = 1;
        
        const ADVANCE_INTERVAL_INIT = 10000;
        const ADVANCE_INTERVAL_MIN = 2000; 
        let advanceInterval = ADVANCE_INTERVAL_INIT;
        let lastAdvanceTime = 0;
        let lastTime = 0;
        let pauseStartTime = 0;

        let bgmOscillator = null;
        let bgmGain = null;
        let bgmSourceNode = null;
        let audioBufferBGM = null;
        let isMuted = false;

        // ÂõæÁâáÁºìÂ≠òÂØπË±° (Key ÊòØ id)
        const characterImages = {};

        const CHARACTERS = [
            { id: 'pink',   color: '#FF007F', name: 'Callie', imgVar: IMG_PINK },   
            { id: 'green',  color: '#00FF21', name: 'Marie', imgVar: IMG_GREEN },    
            { id: 'blue',   color: '#00BFFF', name: 'Boy', imgVar: IMG_BLUE },     
            { id: 'orange', color: '#FF9900', name: 'Girl', imgVar: IMG_ORANGE },   
            { id: 'purple', color: '#9933FF', name: 'Octo', imgVar: IMG_PURPLE }      
        ];

        function loadImages() {
            CHARACTERS.forEach(char => {
                const src = char.imgVar;
                if (src && src !== DEFAULT_PLACEHOLDER && src.startsWith("data:image")) {
                    const img = new Image();
                    img.src = src;
                    img.onload = () => { characterImages[char.id] = { loaded: true, img: img }; };
                    img.onerror = () => { characterImages[char.id] = { loaded: false }; };
                } else {
                    characterImages[char.id] = { loaded: false };
                }
            });
        }
        loadImages();
        
        function initHighScore() {
            try {
                const saved = localStorage.getItem('splat_high_score');
                const savedMute = localStorage.getItem('splat_is_muted'); 
                
                if (saved) {
                    highScore = parseInt(saved);
                }
                highScoreEl.innerText = highScore;
                
                if (savedMute === 'true') {
                    isMuted = true;
                    if(muteBtn) muteBtn.querySelector('i').textContent = 'üîá';
                }
            } catch(e) {
                console.warn("LocalStorage access failed");
            }
        }
        initHighScore();

        const AudioContext = window.AudioContext || window.webkitAudioContext;

        async function initAudio() {
            try {
                if (BGM_CUSTOM_URL && BGM_CUSTOM_URL.length > 50 && BGM_CUSTOM_URL.startsWith('data:audio/') && BGM_CUSTOM_URL !== "data:audio/mp3;base64,PLACEHOLDER_NO_BGM") {
                    if (!audioCtx) audioCtx = new AudioContext();
                    if (!audioBufferBGM) {
                        const base64Data = BGM_CUSTOM_URL.split(',')[1];
                        if (base64Data) {
                            const audioData = atob(base64Data);
                            const buffer = new Uint8Array(audioData.length);
                            for (let i = 0; i < audioData.length; ++i) {
                                buffer[i] = audioData.charCodeAt(i);
                            }
                            audioBufferBGM = await audioCtx.decodeAudioData(buffer.buffer);
                        }
                    }
                }
            } catch (e) {
                console.warn("Audio init failed or skipped, game will continue silent.", e);
                audioBufferBGM = false;
            }
        }

        function playBGM() {
            stopBGM();
            if (!audioCtx || audioCtx.state !== 'running' || isMuted || !audioBufferBGM) return;

            try {
                bgmGain = audioCtx.createGain();
                bgmGain.gain.setValueAtTime(0.4, audioCtx.currentTime); 
                bgmGain.connect(audioCtx.destination);
                
                bgmSourceNode = audioCtx.createBufferSource();
                bgmSourceNode.buffer = audioBufferBGM;
                bgmSourceNode.loop = true;
                bgmSourceNode.connect(bgmGain);
                bgmSourceNode.start(0);
            } catch (e) {
                console.warn("Play BGM failed", e);
            }
        }

        function stopBGM() {
            if (bgmSourceNode) {
                try { bgmSourceNode.stop(audioCtx.currentTime); } catch(e) {}
                bgmSourceNode = null;
            }
            if (bgmOscillator) {
                try { bgmOscillator.stop(audioCtx.currentTime); } catch(e) {}
                bgmOscillator = null;
            }
            bgmGain = null;
        }
        
        function toggleMute() {
            isMuted = !isMuted;
            try { localStorage.setItem('splat_is_muted', isMuted); } catch(e){}
            
            if (isMuted) {
                muteBtn.querySelector('i').textContent = 'üîá';
                if (bgmGain) bgmGain.gain.setValueAtTime(0, audioCtx.currentTime);
            } else {
                muteBtn.querySelector('i').textContent = 'üîä';
                if (bgmGain) bgmGain.gain.setValueAtTime(0.4, audioCtx.currentTime);
                if (gameState === 'PLAYING' && audioBufferBGM) {
                    playBGM();
                }
            }
        }

        function playTone(freq, type, duration, vol = 0.1) {
            if (!audioCtx || audioCtx.state !== 'running' || isMuted) return; 
            
            try {
                const finalFreq = freq * comboPitchMultiplier; 
                
                const osc = audioCtx.createOscillator();
                const gain = audioCtx.createGain();
                osc.type = type;
                osc.frequency.setValueAtTime(finalFreq, audioCtx.currentTime);
                gain.gain.setValueAtTime(vol, audioCtx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
                osc.connect(gain);
                gain.connect(audioCtx.destination);
                osc.start();
                osc.stop(audioCtx.currentTime + duration);
            } catch (e) {}
        }

        const SFX = {
            shoot: () => {
                if (!audioCtx || audioCtx.state !== 'running' || isMuted) return; 
                try {
                    const osc = audioCtx.createOscillator();
                    const gain = audioCtx.createGain();
                    osc.frequency.setValueAtTime(400, audioCtx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(1200, audioCtx.currentTime + 0.1);
                    gain.gain.setValueAtTime(0.1, audioCtx.currentTime);
                    gain.gain.linearRampToValueAtTime(0, audioCtx.currentTime + 0.1);
                    osc.connect(gain);
                    gain.connect(audioCtx.destination);
                    osc.start();
                    osc.stop(audioCtx.currentTime + 0.1);
                } catch(e) {}
            },
            pop: () => playTone(600 + Math.random()*200, 'sine', 0.1, 0.15),
            advance: () => playTone(100, 'sawtooth', 0.5, 0.1),
            gameOver: () => playTone(150, 'sawtooth', 1.0, 0.2),
            countdown: () => playTone(800, 'square', 0.1, 0.1)
        };

        function showStartScreen() {
            stopBGM(); 
            gameState = 'MENU';
            isGameOver = true;
            isPaused = true;
            if (animationId) cancelAnimationFrame(animationId);
            
            gameOverOverlay.classList.remove('active');
            pauseOverlay.classList.remove('active');
            restartOverlay.classList.remove('active');
            startOverlay.classList.add('active');
        }

        const handleStartGame = (e) => {
            if (e) {
                if(e.cancelable) e.preventDefault();
                e.stopPropagation();
            }

            startOverlay.classList.remove('active');

            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                }
                
                if (audioCtx.state === 'suspended') {
                    audioCtx.resume();
                }

                const buffer = audioCtx.createBuffer(1, 1, 22050);
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(audioCtx.destination);
                source.start(0);
                
                initAudio().then(() => {
                    playBGM();
                });
            } catch (err) {
                console.warn("Audio context unlock failed, playing without sound.", err);
            }

            startCountdown();
        };

        if (startBtn) {
            startBtn.addEventListener('touchstart', handleStartGame, { passive: false });
            startBtn.addEventListener('click', handleStartGame);
        }
        
        function startCountdown() {
            gameState = 'COUNTDOWN';
            let val = 3;
            
            resetGameLogic();
            
            countdownEl.innerText = "READY?";
            countdownEl.style.display = "block";
            countdownEl.style.color = "#ff007f";
            SFX.countdown();

            setTimeout(() => {
                countdownEl.innerText = "INK...";
                countdownEl.style.color = "#f1c40f";
                SFX.countdown();
            }, 800);

            setTimeout(() => {
                countdownEl.innerText = "SPLAT!!";
                countdownEl.style.color = "#00ffcc";
                countdownEl.style.textShadow = "0 0 30px #00ffcc";
                SFX.advance();
                
                gameState = 'PLAYING';
                isPaused = false;
                
                setTimeout(() => {
                    countdownEl.style.display = "none";
                }, 1000);
            }, 1600);

            if (animationId) cancelAnimationFrame(animationId);
            gameLoop(performance.now());
        }

        function openRestartOverlay() {
            if (gameState !== 'PLAYING') return;
            
            isPaused = true;
            gameState = 'PAUSED';
            stopBGM();
            pauseStartTime = performance.now();
            cancelAnimationFrame(animationId);
            
            restartOverlay.classList.add('active');
        }
        
        function closeRestartOverlay() {
            restartOverlay.classList.remove('active');
            isPaused = false;
            gameState = 'PLAYING';
            const pausedDuration = performance.now() - pauseStartTime;
            lastAdvanceTime += pausedDuration;
            lastTime = performance.now();
            
            playBGM();
            gameLoop(performance.now());
        }
        
        function confirmRestartAction() {
            restartOverlay.classList.remove('active');
            startCountdown(); 
        }
        
        function confirmRestart() {
            openRestartOverlay();
        }

        function togglePause() {
            if (gameState !== 'PLAYING' && gameState !== 'PAUSED') return;
            
            if (!isPaused) {
                isPaused = true;
                gameState = 'PAUSED';
                stopBGM(); 
                pauseOverlay.classList.add('active');
                pauseStartTime = performance.now();
                cancelAnimationFrame(animationId);
            } else {
                isPaused = false;
                gameState = 'PLAYING';
                playBGM(); 
                pauseOverlay.classList.remove('active');
                const pausedDuration = performance.now() - pauseStartTime;
                lastAdvanceTime += pausedDuration;
                lastTime = performance.now();
                gameLoop(performance.now());
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'p' || e.key === 'P') togglePause();
        });

        function getRandomChar() {
            return CHARACTERS[Math.floor(Math.random() * CHARACTERS.length)];
        }

        function initGrid() {
            grid = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                grid[r] = [];
                for (let c = 0; c < GRID_COLS; c++) {
                    if (r < 5) { 
                        const char = getRandomChar();
                        grid[r][c] = {
                            char: char, 
                            active: true
                        };
                    } else {
                        grid[r][c] = { char: null, active: false };
                    }
                }
            }
        }

        function createBubble() {
            const char = nextBubbleType || getRandomChar();
            nextBubbleType = getRandomChar();
            
            return {
                x: canvas.width / 2,
                y: canvas.height - 60, 
                char: char,
                angle: -Math.PI / 2,
                speed: 16, 
                moving: false,
                scale: 0 
            };
        }
        
        function swapBubbles() {
            if (currentBubble.moving || gameState !== 'PLAYING') return;
            
            const tempChar = currentBubble.char;
            currentBubble.char = nextBubbleType;
            nextBubbleType = tempChar;
            
            currentBubble.scale = 0; 
            playTone(300, 'sine', 0.1, 0.05);
        }

        function resetGameLogic() {
            score = 0;
            scoreEl.innerText = score;
            isGameOver = false;
            isPaused = false;
            comboPitchMultiplier = 1.0; 
            
            gameOverOverlay.classList.remove('active');
            pauseOverlay.classList.remove('active');
            restartOverlay.classList.remove('active'); 
            
            particles = [];
            fallingBubbles = []; 
            inkSplats = []; 
            floatingTexts = []; 
            trail = []; 
            
            initGrid();
            nextBubbleType = getRandomChar();
            currentBubble = createBubble();
            gridOffset = 0; 
            
            lastAdvanceTime = performance.now();
            advanceInterval = ADVANCE_INTERVAL_INIT;
            lastTime = performance.now();
            
            playBGM(); 
            
            if (animationId) cancelAnimationFrame(animationId);
            gameLoop(performance.now());
        }
        
        function resetGame() {
             startCountdown();
        }
        
        function createInkSplat(x, y, color) {
            const splat = {
                x: x,
                y: y,
                color: color,
                life: 1.0,
                rotation: Math.random() * Math.PI * 2,
                blobs: []
            };
            
            const mainRadius = TILE_RADIUS * (1.2 + Math.random() * 0.5);
            splat.blobs.push({dx: 0, dy: 0, r: mainRadius});

            const lobes = 4 + Math.floor(Math.random() * 3);
            for (let i = 0; i < lobes; i++) {
                const angle = (i / lobes) * Math.PI * 2 + (Math.random() * 0.5);
                const dist = mainRadius * 0.6;
                const r = mainRadius * 0.7;
                splat.blobs.push({dx: Math.cos(angle) * dist, dy: Math.sin(angle) * dist, r: r});
            }
            
            inkSplats.push(splat);
            if (inkSplats.length > MAX_INK_SPLATS) inkSplats.shift(); 
        }

        function updateInkSplats() {
            for (let i = inkSplats.length - 1; i >= 0; i--) {
                let s = inkSplats[i];
                s.life -= 0.0008; 
                if (s.life <= 0) inkSplats.splice(i, 1);
            }
        }

        function drawInkSplatsBackground(ctx) {
            ctx.clearRect(0, 0, inkCanvas.width, inkCanvas.height); 
            
            inkSplats.forEach(s => {
                ctx.globalAlpha = s.life * 0.95;
                ctx.fillStyle = s.color;
                ctx.beginPath();
                s.blobs.forEach(b => {
                    ctx.moveTo(s.x + b.dx, s.y + b.dy);
                    ctx.arc(s.x + b.dx, s.y + b.dy, b.r, 0, Math.PI * 2);
                });
                ctx.fill();
            });
        }

        function drawInkSplatsHighlights(ctx) {
             if (isMobile) return;

             ctx.save();
             inkSplats.forEach(s => {
                ctx.globalAlpha = s.life * 0.3;
                ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                ctx.beginPath();
                const highlightSize = TILE_RADIUS * 0.8;
                ctx.ellipse(
                    s.x - highlightSize * 0.4, 
                    s.y - highlightSize * 0.4, 
                    highlightSize * 0.6, 
                    highlightSize * 0.25, 
                    Math.PI / 4, 
                    0, Math.PI * 2
                );
                ctx.fill();
             });
             ctx.restore();
        }
        
        function createFloatingText(x, y, text, color, type = 'default') {
            let startY = y;
            let speed = -2.0;
            let scale = 0.1;
            
            if (type === 'combo') {
                startY = y - 50; 
                speed = -1.0; 
                color = "#00ffcc"; 
            }

            floatingTexts.push({
                x: x,
                y: startY,
                text: text,
                color: color,
                type: type,
                life: 1.0,
                dy: speed, 
                vx: (Math.random() - 0.5) * 2, 
                scale: scale,
                rotation: (Math.random() - 0.5) * 0.5 
            });
        }
        
        function updateFloatingTexts() {
            for (let i = floatingTexts.length - 1; i >= 0; i--) {
                let ft = floatingTexts[i];
                ft.y += ft.dy;
                if (ft.scale < 1.0) ft.scale += 0.1; 
                if (ft.scale > 1.0) ft.scale = 1.0;
                
                ft.life -= 0.015; 
                if (ft.life <= 0) floatingTexts.splice(i, 1);
            }
        }
        
        function drawFloatingTexts(ctx) {
            ctx.save();
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            floatingTexts.forEach(ft => {
                ctx.save();
                ctx.translate(ft.x, ft.y);
                ctx.rotate(ft.rotation);
                ctx.scale(ft.scale, ft.scale);
                
                ctx.globalAlpha = ft.life;
                
                ctx.font = "900 28px 'Segoe UI', Arial, sans-serif"; 
                ctx.lineWidth = 6;
                ctx.strokeStyle = "rgba(0,0,0,0.8)"; 
                ctx.lineJoin = "round";
                ctx.strokeText(ft.text, 0, 0);
                
                ctx.fillStyle = ft.color;
                ctx.fillText(ft.text, 0, 0);
                
                ctx.fillStyle = "rgba(255,255,255,0.4)";
                ctx.fillText(ft.text, -2, -2);

                ctx.restore();
            });
            ctx.restore();
        }
        
        function triggerShake(intensity) {
            shakeDuration = isMobile ? intensity * 0.5 : intensity;
        }

        function updateShake() {
            if (shakeDuration > 0) {
                shakeX = (Math.random() - 0.5) * shakeDuration;
                shakeY = (Math.random() - 0.5) * shakeDuration;
                shakeDuration *= 0.9; 
                if (shakeDuration < 0.5) {
                    shakeDuration = 0;
                    shakeX = 0;
                    shakeY = 0;
                }
            }
        }

        function getTileCoordinate(row, col) {
            const isOddRow = (row + gridOffset) % 2 !== 0;
            const offset = isOddRow ? TILE_RADIUS : 0;
            const x = (col * TILE_DIAMETER) + TILE_RADIUS + offset;
            const y = (row * ROW_HEIGHT) + TILE_RADIUS + 20; 
            return { x, y };
        }
        
        function getBreathingOffset(timestamp) {
            return Math.sin(timestamp / 400) * 2; 
        }

        function getClosestGridPosition(x, y) {
            let minDist = Infinity;
            let closest = { r: -1, c: -1 };
            
            const approxRow = Math.floor((y - 20 - TILE_RADIUS) / ROW_HEIGHT);
            const startRow = Math.max(0, approxRow - 2);
            const endRow = Math.min(GRID_ROWS - 1, approxRow + 2);

            for (let r = startRow; r <= endRow; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c].active) continue;
                    
                    const pos = getTileCoordinate(r, c);
                    const dist = Math.hypot(pos.x - x, pos.y - y);
                    
                    if (dist < minDist && dist < TILE_RADIUS * 1.5) {
                        if (r === 0 || hasActiveNeighbor(r, c)) {
                            minDist = dist;
                            closest = { r, c };
                        }
                    }
                }
            }
            return closest;
        }
        
        function hasActiveNeighbor(r, c) {
            const neighbors = getNeighbors(r, c);
            for (let n of neighbors) {
                if (grid[n.r][n.c].active) return true;
            }
            return false;
        }

        function getNeighbors(r, c) {
            const neighbors = [];
            const isEven = (r + gridOffset) % 2 === 0; 
            const offsets = isEven ? [
                [-1, -1], [-1, 0], [0, -1], [0, 1], [1, -1], [1, 0]
            ] : [
                [-1, 0], [-1, 1], [0, -1], [0, 1], [1, -1], [1, 0]
            ];
            for (let offset of offsets) {
                const nr = r + offset[0];
                const nc = c + offset[1];
                if (nr >= 0 && nr < GRID_ROWS && nc >= 0 && nc < GRID_COLS) {
                    neighbors.push({ r: nr, c: nc });
                }
            }
            return neighbors;
        }

        function findCluster(r, c, matchId, reset, checked) {
            if (reset) checked = new Set();
            const key = `${r},${c}`;
            if (checked.has(key)) return [];
            if (grid[r][c].active && grid[r][c].char.id === matchId) {
                checked.add(key);
                let cluster = [{ r, c }];
                const neighbors = getNeighbors(r, c);
                for (let n of neighbors) {
                    cluster = cluster.concat(findCluster(n.r, n.c, matchId, false, checked));
                }
                return cluster;
            }
            return [];
        }

        function findFloatingClusters() {
            let visited = new Set();
            let queue = [];
            for (let c = 0; c < GRID_COLS; c++) {
                if (grid[0][c].active) {
                    queue.push({r: 0, c: c});
                    visited.add(`0,${c}`);
                }
            }
            while (queue.length > 0) {
                let curr = queue.shift();
                let neighbors = getNeighbors(curr.r, curr.c);
                
                for (let n of neighbors) { 
                    if (grid[n.r] && grid[n.r][n.c] && grid[n.r][n.c].active && !visited.has(`${n.r},${n.c}`)) {
                        visited.add(`${n.r},${n.c}`);
                        queue.push(n);
                    }
                }
            }
            
            let floating = [];
            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c].active && !visited.has(`${r},${c}`)) {
                        floating.push({r, c});
                    }
                }
            }
            return floating;
        }
        
        function dropBubbles(floatingNodes) {
            if (floatingNodes.length > 3) triggerShake(10);
            
            const firstNode = floatingNodes[0];
            if (firstNode) {
                const pos = getTileCoordinate(firstNode.r, firstNode.c);
                createFloatingText(pos.x, pos.y, "Combo!", "#00ffcc", 'combo');
            }

            floatingNodes.forEach(node => {
                const r = node.r;
                const c = node.c;
                const cell = grid[r][c];
                
                const pos = getTileCoordinate(r, c);
                fallingBubbles.push({
                    x: pos.x,
                    y: pos.y,
                    char: cell.char,
                    vx: (Math.random() - 0.5) * 4, 
                    vy: 0, 
                    r: r, 
                    c: c
                });

                grid[r][c] = { char: null, active: false };
            });
        }

        function updateFallingBubbles() {
            for (let i = fallingBubbles.length - 1; i >= 0; i--) {
                let b = fallingBubbles[i];
                b.vy += 0.5; 
                b.x += b.vx;
                b.y += b.vy;

                if (b.y > canvas.height + 50) {
                    fallingBubbles.splice(i, 1);
                    score += 20; 
                    scoreEl.innerText = score;
                    
                     scoreEl.classList.remove('score-pop');
                    void scoreEl.offsetWidth; 
                    scoreEl.classList.add('score-pop');
                }
            }
        }
        
        function drawFallingBubbles(ctx) {
            fallingBubbles.forEach(b => {
                drawCharacterAvatar(ctx, b.x, b.y, TILE_RADIUS, b.char);
            });
        }

        function advanceRow() {
            SFX.advance();
            triggerShake(5); 
            createFloatingText(canvas.width/2, canvas.height/2, "SPEED UP!", "#f1c40f", 'combo');
            
            if (checkDeathLineTouched(GRID_ROWS - 2)) {
                triggerGameOver();
                return;
            }
            gridOffset = 1 - gridOffset;

            for (let r = GRID_ROWS - 1; r > 0; r--) {
                for (let c = 0; c < GRID_COLS; c++) {
                    grid[r][c] = grid[r - 1][c];
                }
            }
            for (let c = 0; c < GRID_COLS; c++) {
                grid[0][c] = {
                    char: getRandomChar(),
                    active: true
                };
            }
            if (checkDeathLineTouched(DEAD_LINE_ROW)) {
                triggerGameOver();
            }
        }

        function checkDeathLineTouched(limitRow) {
            for (let r = limitRow; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r][c].active) return true;
                }
            }
            return false;
        }

        function triggerGameOver() {
            stopBGM(); 
            gameState = 'GAMEOVER';
            SFX.gameOver();
            
            if (score > highScore) {
                highScore = score;
                localStorage.setItem('splat_high_score', highScore);
                highScoreEl.innerText = highScore;
                newRecordText.style.display = "block"; 
            } else {
                newRecordText.style.display = "none";
            }

            finalScoreEl.innerText = score;
            gameOverOverlay.classList.add('active');
        }

        function drawCharacterAvatar(ctx, x, y, size, char, scale = 1.0) {
            ctx.save();
            ctx.translate(x, y);
            ctx.scale(scale, scale);

            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.fillStyle = char.color;
            ctx.fill();

            let imgToDraw;
            let isCurrentImgLoaded;
            
            let charData = characterImages[char.id];
            if (charData && charData.loaded) {
                imgToDraw = charData.img;
                isCurrentImgLoaded = true;
            }

            if (isCurrentImgLoaded) {
                ctx.save();
                ctx.beginPath();
                ctx.arc(0, 0, size * 0.9, 0, Math.PI * 2);
                ctx.clip();
                const drawSize = size * 2;
                ctx.drawImage(imgToDraw, -drawSize/2, -drawSize/2, drawSize, drawSize);
                ctx.fillStyle = char.color;
                ctx.globalAlpha = 0.2; 
                ctx.fill();
                ctx.restore();
            }

            if (!isMobile) {
                const gradient = ctx.createRadialGradient(-size*0.3, -size*0.3, size*0.2, 0, 0, size);
                gradient.addColorStop(0, "rgba(255,255,255,0.3)"); 
                gradient.addColorStop(1, "rgba(0,0,0,0.1)");
                ctx.fillStyle = gradient;
                ctx.beginPath(); ctx.arc(0, 0, size, 0, Math.PI * 2); ctx.fill();

                ctx.beginPath();
                ctx.ellipse(-size*0.4, -size*0.4, size*0.3, size*0.2, Math.PI/4, 0, Math.PI*2);
                ctx.fillStyle = "rgba(255, 255, 255, 0.6)"; 
                ctx.fill();
            }
            
            ctx.beginPath();
            ctx.arc(0, 0, size, 0, Math.PI * 2);
            ctx.strokeStyle = "rgba(0,0,0,0.5)";
            ctx.lineWidth = 2;
            ctx.stroke();

            ctx.restore();
        }
        
        function drawSwapButton(ctx) {
             const centerX = canvas.width/2 + TILE_DIAMETER * 1.5;
             const centerY = canvas.height - 60;
             const radius = 18;
             
             ctx.save();
             ctx.translate(centerX, centerY);
             
             ctx.beginPath();
             ctx.arc(0, 0, radius, 0, Math.PI*2);
             ctx.fillStyle = "rgba(0, 0, 0, 0.6)";
             ctx.fill();
             ctx.strokeStyle = "#666";
             ctx.lineWidth = 2;
             ctx.stroke();
             
             if (nextBubbleType) {
                 drawCharacterAvatar(ctx, 0, 0, radius * 0.7, nextBubbleType);
             }
             
             ctx.beginPath();
             ctx.arc(0, 0, radius + 4, 0, Math.PI*2, false);
             ctx.strokeStyle = "#fff";
             ctx.lineWidth = 2;
             ctx.setLineDash([5, 5]);
             ctx.stroke();
             
             ctx.restore();
        }

        function createExplosion(x, y, color) {
            triggerShake(3); 
            createInkSplat(x, y, color);
            
            for(let i=0; i<PARTICLE_COUNT; i++) { 
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    size: Math.random() * 5 + 3, 
                    color: color
                });
            }
        }

        function updateParticles() {
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx;
                p.y += p.vy;
                p.vy += 0.4; 
                p.life -= 0.07; 
                if (p.life <= 0) particles.splice(i, 1);
            }
        }

        function drawDeadLine() {
            ctx.save();
            ctx.beginPath();
            const y = DEAD_LINE_Y; 
            ctx.moveTo(0, y);
            ctx.lineTo(canvas.width, y);
            
            let bottomRow = 0;
            for(let r=GRID_ROWS-1; r>=0; r--) {
                let has = false;
                for(let c=0; c<GRID_COLS; c++) {
                    if(grid[r] && grid[r][c] && grid[r][c].active) { has = true; break; }
                }
                if(has) { bottomRow = r; break; }
            }
            
            const dist = DEAD_LINE_ROW - bottomRow;
            if (dist <= 2) {
                const pulse = Math.sin(Date.now() / 100) * 0.5 + 0.5;
                ctx.strokeStyle = `rgba(255, 0, 85, ${0.5 + pulse * 0.5})`;
                ctx.lineWidth = 4 + pulse * 2;
                ctx.shadowBlur = isMobile ? 0 : 20; 
            } else {
                ctx.strokeStyle = "#ff0055"; 
                ctx.lineWidth = 4; 
                ctx.shadowBlur = isMobile ? 0 : 10;
            }

            ctx.setLineDash([15, 10]);
            ctx.stroke();
            
            ctx.fillStyle = "#ff0055";
            ctx.font = "bold 16px Courier New";
            ctx.fillText("DANGER ZONE", 10, y - 10);
            ctx.restore();
        }
        
        function drawGuideLine() {
            const startX = currentBubble.x;
            const startY = currentBubble.y;
            const dx = Math.cos(currentBubble.angle);
            const dy = Math.sin(currentBubble.angle);
            
            ctx.save();
            
            const offset = -Date.now() / 20;
            ctx.lineDashOffset = offset;
            
            ctx.strokeStyle = "rgba(0, 255, 204, 0.6)"; 
            ctx.setLineDash([15, 10]); 
            ctx.lineWidth = 3;
            if(!isMobile) {
                ctx.shadowBlur = 8;
                ctx.shadowColor = "#00ffcc";
            }
            ctx.beginPath();
            ctx.moveTo(startX, startY);
            
            let wallDist = Infinity;
            let wallX = 0;
            
            if (dx > 0) { 
                wallDist = (canvas.width - TILE_RADIUS - startX) / dx;
                wallX = canvas.width - TILE_RADIUS;
            } else if (dx < 0) { 
                wallDist = (TILE_RADIUS - startX) / dx;
                wallX = TILE_RADIUS;
            }
            
            const rayLen = 800;
            
            if (wallDist < rayLen && wallDist > 0) {
                const hitY = startY + dy * wallDist;
                ctx.lineTo(wallX, hitY);
                
                const bounceDx = -dx;
                const remainLen = rayLen - wallDist;
                const endX = wallX + bounceDx * remainLen;
                const endY = hitY + dy * remainLen;
                
                ctx.lineTo(endX, endY);
            } else {
                 ctx.lineTo(startX + dx * rayLen, startY + dy * rayLen);
            }
            
            ctx.stroke();
            ctx.restore();
        }
        
        function drawCountdownDisplay(ctx) {
            ctx.save();
            ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.translate(canvas.width/2, canvas.height/2);
            if (countdownScale > 1) countdownScale -= 0.05;
            ctx.scale(countdownScale, countdownScale);
            
            ctx.fillStyle = "#ff007f";
            ctx.strokeStyle = "#fff";
            ctx.lineWidth = 8;
            ctx.font = "900 120px 'Courier New', monospace";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            
            let text = countdownValue > 0 ? countdownValue : "PAINT!";
            ctx.strokeText(text, 0, 0);
            ctx.fillText(text, 0, 0);
            
            ctx.restore();
        }

        function gameLoop(timestamp) {
            if (isPaused) return; 

            if (!lastTime) lastTime = timestamp;
            const deltaTime = timestamp - lastTime;
            lastTime = timestamp;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            if (gameState === 'COUNTDOWN') {
                drawInkSplatsBackground(inkCtx);
                if (!isMobile) drawInkSplatsHighlights(ctx);
                drawDeadLine();
                for (let r = 0; r < GRID_ROWS; r++) {
                    for (let c = 0; c < GRID_COLS; c++) {
                        if (grid[r] && grid[r][c] && grid[r][c].active) {
                            const pos = getTileCoordinate(r, c);
                            drawCharacterAvatar(ctx, pos.x, pos.y, TILE_RADIUS, grid[r][c].char);
                        }
                    }
                }
                if (currentBubble) drawCharacterAvatar(ctx, currentBubble.x, currentBubble.y, TILE_RADIUS, currentBubble.char);
                animationId = requestAnimationFrame(gameLoop);
                return;
            }

            const timeSinceAdvance = timestamp - lastAdvanceTime;
            const progress = 1 - (timeSinceAdvance / advanceInterval);
            timerBarEl.style.width = `${Math.max(0, progress * 100)}%`;

            if (timeSinceAdvance > advanceInterval) {
                advanceRow();
                lastAdvanceTime = timestamp;
                advanceInterval = Math.max(ADVANCE_INTERVAL_MIN, advanceInterval - 200); 
            }
            
            if (currentBubble && currentBubble.scale < 1) {
                currentBubble.scale += 0.1;
                if (currentBubble.scale > 1) currentBubble.scale = 1;
            }

            updateParticles();
            updateFallingBubbles();
            updateInkSplats();
            updateFloatingTexts(); 
            updateShake(); 
            
            if (currentBubble.moving) {
                trail.push({x: currentBubble.x, y: currentBubble.y, life: 1.0, color: currentBubble.char.color});
            }
            for(let i=trail.length-1; i>=0; i--) {
                trail[i].life -= 0.05;
                if(trail[i].life <= 0) trail.splice(i, 1);
            }

            if (currentBubble.moving) {
                const steps = 2;
                const speedPerStep = currentBubble.speed / steps;
                
                for(let s=0; s<steps; s++) {
                    if (!currentBubble.moving) break;
                    
                    currentBubble.x += Math.cos(currentBubble.angle) * speedPerStep;
                    currentBubble.y += Math.sin(currentBubble.angle) * speedPerStep;

                    if (currentBubble.x - TILE_RADIUS <= 0 || currentBubble.x + TILE_RADIUS >= canvas.width) {
                        currentBubble.angle = Math.PI - currentBubble.angle;
                        currentBubble.x = Math.max(TILE_RADIUS, Math.min(canvas.width - TILE_RADIUS, currentBubble.x));
                    }

                    let hit = false;
                    if (currentBubble.y - TILE_RADIUS <= 20) { 
                        hit = true;
                    } else {
                        const collisionRadius = TILE_DIAMETER - 4; 
                        for (let r = 0; r < GRID_ROWS; r++) {
                            for (let c = 0; c < GRID_COLS; c++) {
                                if (grid[r] && grid[r][c] && grid[r][c].active) {
                                    const pos = getTileCoordinate(r, c);
                                    const dist = Math.hypot(pos.x - currentBubble.x, pos.y - currentBubble.y);
                                    if (dist < collisionRadius) { 
                                        hit = true;
                                        break;
                                    }
                                }
                            }
                            if (hit) break;
                        }
                    }

                    if (hit) {
                        currentBubble.moving = false;
                        trail = []; 
                        const snap = getClosestGridPosition(currentBubble.x, currentBubble.y);
                        if (snap.r !== -1) {
                            grid[snap.r][snap.c] = { active: true, char: currentBubble.char }; 
                            comboPitchMultiplier = 1.0;
                            
                            if (checkDeathLineTouched(DEAD_LINE_ROW)) {
                                triggerGameOver();
                            } else {
                                const cluster = findCluster(snap.r, snap.c, currentBubble.char.id, true);
                                if (cluster.length >= 3) {
                                    comboPitchMultiplier = Math.min(2.0, comboPitchMultiplier + 0.1);
                                    SFX.pop();
                                    
                                    const scoreGain = cluster.length * 100;
                                    score += scoreGain;
                                    
                                    scoreEl.innerText = score;
                                    scoreEl.classList.remove('score-pop');
                                    void scoreEl.offsetWidth; 
                                    scoreEl.classList.add('score-pop');
                                    
                                    const hitPos = getTileCoordinate(snap.r, snap.c);
                                    createFloatingText(hitPos.x, hitPos.y, `+${scoreGain}`, "#fff", 'score');
                                    
                                    cluster.forEach(b => {
                                        const pos = getTileCoordinate(b.r, b.c);
                                        createExplosion(pos.x, pos.y, grid[b.r][b.c].char.color);
                                        grid[b.r][b.c].active = false;
                                    });
                                    const floating = findFloatingClusters();
                                    if (floating.length > 0) {
                                        score += floating.length * 200;
                                        dropBubbles(floating);
                                    }
                                    scoreEl.innerText = score;
                                }
                            }
                        } else {
                            triggerGameOver();
                            return;
                        }
                        if (!isGameOver) currentBubble = createBubble();
                    }
                }
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            ctx.save();
            if (shakeDuration > 0) {
                ctx.translate(shakeX, shakeY);
            }
            
            drawInkSplatsBackground(inkCtx);
            if (!isMobile) drawInkSplatsHighlights(ctx);
            
            drawDeadLine();
            
            const breathY = getBreathingOffset(timestamp);

            for (let r = 0; r < GRID_ROWS; r++) {
                for (let c = 0; c < GRID_COLS; c++) {
                    if (grid[r] && grid[r][c] && grid[r][c].active) {
                        const pos = getTileCoordinate(r, c);
                        drawCharacterAvatar(ctx, pos.x, pos.y + breathY, TILE_RADIUS, grid[r][c].char);
                    }
                }
            }
            
            drawFallingBubbles(ctx);
            
            trail.forEach(t => {
                ctx.globalAlpha = t.life * 0.6;
                ctx.fillStyle = t.color;
                ctx.beginPath();
                ctx.arc(t.x, t.y, TILE_RADIUS * 0.6 * t.life, 0, Math.PI*2);
                ctx.fill();
            });
            ctx.globalAlpha = 1.0;

            if (!currentBubble.moving && !isGameOver) {
                drawGuideLine(); 
                drawSwapButton(ctx);
            }

            if (!isGameOver) {
                drawCharacterAvatar(ctx, currentBubble.x, currentBubble.y, TILE_RADIUS, currentBubble.char, currentBubble.scale);
            }

            ctx.fillStyle = "rgba(0, 255, 204, 0.9)";
            ctx.font = "bold 16px Courier New";
            ctx.fillText("NEXT", 20, canvas.height - 40);
            drawCharacterAvatar(ctx, 80, canvas.height - 45, TILE_RADIUS * 0.8, nextBubbleType);

            particles.forEach(p => {
                ctx.globalAlpha = p.life;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
                ctx.fillStyle = p.color;
                ctx.fill();
                ctx.globalAlpha = 1.0;
            });
            
            drawFloatingTexts(ctx);
            
            ctx.restore(); 
            
            if (!isGameOver) {
                animationId = requestAnimationFrame(gameLoop);
            }
        }

        // 7. ‰∫ã‰ª∂ÁõëÂê¨‰øÆÂ§çÔºöËé∑ÂèñÊ≠£Á°ÆÁöÑÁõ∏ÂØπÂùêÊ†á
        function getCanvasRelativeCoordinates(event) {
            const rect = canvas.getBoundingClientRect();
            // Â§ÑÁêÜÈº†Ê†áÊàñËß¶Êë∏‰∫ã‰ª∂
            const clientX = event.clientX || (event.touches && event.touches[0].clientX);
            const clientY = event.clientY || (event.touches && event.touches[0].clientY);
            
            if (clientX === undefined || clientY === undefined) return null;

            // ËÆ°ÁÆóÁº©ÊîæÊØî‰æã
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            return {
                x: (clientX - rect.left) * scaleX,
                y: (clientY - rect.top) * scaleY
            };
        }

        const handleMove = (e) => {
            if (isGameOver || isPaused || !currentBubble) return;

            const pos = getCanvasRelativeCoordinates(e);
            if (!pos) return;

            if (!currentBubble.moving) {
                const dx = pos.x - currentBubble.x;
                const dy = pos.y - currentBubble.y;
                let angle = Math.atan2(dy, dx);
                
                // ‰øÆÂ§çÈÄªËæëÔºöÈò≤Ê≠¢Âú®Â∫ïÈÉ®Âå∫ÂüüÊìç‰ΩúÊó∂ÔºåËßíÂ∫¶Áû¨Èó¥Ë∑≥ËΩ¨Âà∞ÊúÄÂè≥
                // Â¶ÇÊûúËßíÂ∫¶ÊòØÊ≠£Êï∞ÔºàÂêë‰∏ãÔºâÔºåÊàë‰ª¨Ê†πÊçÆÂ∑¶Âè≥Âå∫ÂàÜÂê∏ÈôÑ
                if (angle > 0 && angle < Math.PI) {
                    if (angle > Math.PI / 2) {
                        angle = -Math.PI + 0.2; // ÊûÅÂ∑¶
                    } else {
                        angle = -0.2; // ÊûÅÂè≥
                    }
                } else {
                     // Ê≠£Â∏∏ÁöÑÂêë‰∏äÁûÑÂáÜÔºåËøõË°åÈôêÂà∂
                     if (angle > -0.2) angle = -0.2;
                     if (angle < -Math.PI + 0.2) angle = -Math.PI + 0.2;
                }
                
                currentBubble.angle = angle;
            }
        };

        canvas.addEventListener('mousemove', handleMove);
        canvas.addEventListener('touchmove', (e) => {
             e.preventDefault(); 
             handleMove(e);
        }, { passive: false });

        const handleInputStart = (e) => {
            if (isGameOver || isPaused || startOverlay.classList.contains('active') || !currentBubble) return;
            
            const pos = getCanvasRelativeCoordinates(e);
            if (!pos) return;
            
            if (pos.y > canvas.height - 100 && !currentBubble.moving) {
                if(e.cancelable) e.preventDefault();
                swapBubbles();
            } else if (!currentBubble.moving) {
                 // Âè™Ë¶ÅÁÇπÂáªÂú® canvas Âå∫ÂüüÂÜÖÔºàÈô§‰∫ÜÂ∫ïÈÉ®‰∫§Êç¢Âå∫ÔºâÈÉΩÁÆóÂèëÂ∞Ñ
                 if(e.cancelable) e.preventDefault();
                 
                 // ÂèëÂ∞ÑÂâçÂÜçÊ¨°Êõ¥Êñ∞ËßíÂ∫¶ÔºåÁ°Æ‰øù‚ÄúÊåáÂì™ÊâìÂì™‚Äù
                 const dx = pos.x - currentBubble.x;
                 const dy = pos.y - currentBubble.y;
                 let angle = Math.atan2(dy, dx);
                 if (angle > 0 && angle < Math.PI) {
                    if (angle > Math.PI / 2) angle = -Math.PI + 0.2;
                    else angle = -0.2;
                 } else {
                     if (angle > -0.2) angle = -0.2;
                     if (angle < -Math.PI + 0.2) angle = -Math.PI + 0.2;
                 }
                 currentBubble.angle = angle;
                 
                 SFX.shoot();
                 currentBubble.moving = true;
            }
        };

        canvas.addEventListener('mousedown', handleInputStart);
        canvas.addEventListener('touchstart', handleInputStart, { passive: false });

        loadImages();

    </script>
</body>
</html>